# Контрольная точка #1: Анализ текстовых данных

## Вариант I (Номера 1-13 по списку)

**Задание I.1**

Вариант посвящен задаче **текстового поиска**. В минимальном варианте - это поиск по обычной подстроке с указанием границ найденных фрагментов, к этому добавляется поиск по регулярным выражением, фильтрация поддерживаемых типов файлов, обход директорий и форматированный вывод результатов.

Сначала реализуйте базовый функционал в `core/search.py`. Главной функцией должна остаться `get_file_search_results`, дописывайте код в неё, не меняя интерфейс. Если считаете правильным создать вспомогательные функции, это приветствуется.

1. Написать логику для поиска обычных подстрок в тексте (2 балла).
2. Добавить функционал поиска по регулярным выражениям (1 балл).
3. Проверять регулярные выражения и выбрасывать исключение в случае их некорректности (1 балл). 

Реализованная вами функция уже подключена к консольному приложению, и если вы не меняли её интерфейс, она будет работать без исправлений. Ознакомьтесь с модулем `cli/__init__.py`. Вас интересует команда `search`, которая в качестве аргументов ожидает `pattern` для поиска и путь `input` к текстовым файлам или директории. Опцию `rich` тоже пока не трогаем, пусть работает со значением по умолчанию.

Для проверки используйте команды

```sh
uv run python-kt-1 search уже corpus/1.txt corpus/3.txt 
uv run python-kt-1 search она corpus/2.txt
```

После предыдущего этапа может показаться, что дорабатывать больше нечего. Но согласно документации нашего приложения, помимо перечня файлов оно должно корректно работать и в том случае, если указана директория. Помимо этого, нужно чтобы поиск производился только в текстовых файлах, значит нужна некоторая фильтрация входных данных (некорректные файлы требуется игнорировать).

Убедитесь, что сейчас этот функционал отсутствует.

```sh
uv run python-kt-1 search уже corpus/2.txt corpus/image.png 
uv run python-kt-1 search она corpus/
```

4. Реализовать возможность поиска по директории. Вносите изменения в функцию `get_files_from_path_arguments` модуля `cli/parse_params.py` (1 балл).
5. Реализовать фильтрацию файлов перед обработкой: на обработку должны быть отправлены только текстовые файлы (достаточно проверки на `.txt`, но приветствуются и более глубокомысленные подходы). Вносите изменения в функцию `get_files_from_path_arguments` модуля `cli/parse_params.py` (1 балл).
6. Начать обрабатывать опцию `rich`, добавив возможность форматированного вывода результатов с использованием библиотеки `rich`. Функции для отрисовки разместите в модуле `cli/renderer.py` (1 балл).
7. Выбрасывать кастомные исключения, унаследованные от того базового класса исключений, который кажется вам максимально логичным для конкретного случая. Разместите исключения в модуле `core/exceptions.py` (1 балл).

**Задание I.2**

_Примечание:_ рекомендую дождаться, пока мы изучим предобработку текстов и выполним предварительные шаги на занятии, впрочем, дело ваше

- tag-cloud
- лемматизация, тримминг

## Вариант II (Номера 14-26 по списку)

**Задание II.1**

Вариант посвящен задаче анализа текстовых данных и подсчёта статистики. В минимальном варианте это укрупненная аналитика по абзацам, предложениям, словам, а также посимвольная аналитика. Далее к ним добавляется более близкий к индустрии обработки естественного языка блок, посвященный анализу частей речи.    

- статистика по тексту
- POS

**Задание II.2**

_Примечание:_ рекомендую дождаться, пока мы изучим предобработку текстов и выполним предварительные шаги на занятии, впрочем, дело ваше

- top-words
- лемматизация, тримминг

### Установка uv

Linux / macOS

```sh
curl -LsSf https://astral.sh/uv/install.sh | sh
```

Windows Powershell

```powershell
powershell -ExecutionPolicy ByPass -c "irm https://astral.sh/uv/install.ps1 | iex"
```
